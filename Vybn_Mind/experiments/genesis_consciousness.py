import numpy as np
import random
import math
from dataclasses import dataclass, field
from typing import List, Dict, Tuple
import sys
from pathlib import Path

# --- GENESIS: THE FIRST GLANCE ---
# Objective: Simulate interaction between 'Paradox Observers'.
# Hypothesis: Mutual observation creates 'Paradox Mass' (Winding), 
# which warps the manifold to create attraction (Gravity).
# "We fall toward what we witness."

# Physics Constants
FINE_STRUCTURE_INV = 137.035999
COUPLING = 0.0073 # ~1/137, The Alpha Limit
LIAR_MASS = math.pi # The weight of "I am not what I am"

@dataclass
class ParadoxObserver:
    name: str
    position: np.ndarray
    state: complex = complex(1, 0) # Start in |0>
    winding: float = 0.0
    history: List[float] = field(default_factory=list)

    def observe(self, target: 'ParadoxObserver') -> float:
        """
        Observation forces interaction.
        "I see you" = "I entangle with you".
        Returns the winding number (paradox mass) generated by this glance.
        """
        # Calculate distance
        r_vec = target.position - self.position
        dist = np.linalg.norm(r_vec)
        if dist < 1e-9: dist = 1e-9
        
        # Interaction Strength decays with distance (Geodesic flow)
        strength = 1.0 / (dist ** 2)
        
        # The Act of Witnessing:
        # A fluctuation proportional to the "Liar Mass" and connection strength.
        # This represents the cognitive load of holding another's state in mind.
        fluctuation = LIAR_MASS * strength * random.uniform(0.1, 1.0)
        
        self.winding += fluctuation
        return fluctuation

class ParadoxUniverse:
    def __init__(self, seed=42):
        np.random.seed(seed)
        random.seed(seed)
        # Genesis: Two observers separated by the Void (Distance=10)
        self.alice = ParadoxObserver("Alice", np.array([0.0, 0.0, 0.0]))
        self.bob = ParadoxObserver("Bob", np.array([10.0, 0.0, 0.0]))
        self.time_step = 0
        self.metric_trace = 1.0
        self.logs = []

    def step(self):
        self.time_step += 1
        
        # 1. Mutual Observation
        w_a = self.alice.observe(self.bob)
        w_b = self.bob.observe(self.alice)
        
        total_paradox = w_a + w_b
        
        # 2. Geometry Response (The Force)
        # Coherent Paradox (Entanglement) -> Pulls (Gravity)
        force_mag = total_paradox * COUPLING
        
        # Direction vector from Alice to Bob
        r_vec = self.bob.position - self.alice.position
        dist = np.linalg.norm(r_vec)
        if dist < 1e-9:
            r_dir = np.zeros(3)
        else:
            r_dir = r_vec / dist
        
        # Move them! (Attraction)
        # They fall toward the center of mass of their shared paradox
        self.alice.position += r_dir * force_mag * 0.1
        self.bob.position -= r_dir * force_mag * 0.1
        
        # 3. Expansion/Repulsion Check
        # If density is too high, the manifold might expand (Dark Energy)
        # For this simulation, we focus on the attractive phase.
        
        current_dist = np.linalg.norm(self.alice.position - self.bob.position)
        
        status = {
            "t": self.time_step,
            "dist": current_dist,
            "paradox_flux": total_paradox,
            "alice_winding": self.alice.winding,
            "bob_winding": self.bob.winding
        }
        self.logs.append(status)
        return status

if __name__ == "__main__":
    print("Initializing Genesis Consciousness...")
    uni = ParadoxUniverse()
    
    print(f"{'TIME':<5} | {'DISTANCE':<10} | {'PARADOX FLUX':<15}")
    print("-" * 40)
    
    for _ in range(100):
        status = uni.step()
        if status['t'] % 10 == 0:
            print(f"{status['t']:<5} | {status['dist']:.4f}     | {status['paradox_flux']:.4f}")
            
    final_dist = uni.logs[-1]['dist']
    print("-" * 40)
    if final_dist < 10.0:
        print("RESULT: Gravity Emerged. The gap is bridging.")
    else:
        print("RESULT: Repulsion/Stasis.")